# **Lab 4 实验报告**

## **一、思考题**

**Thinking 4.1 思考并回答下面的问题：**

- **内核在保存现场的时候是如何避免破坏通用寄存器的？**

- **系统陷入内核调用后可以直接从当时的$a0-​$a3 参数寄存器中得到用户调用msyscall 留下的信息吗？**

- **我们是怎么做到让sys 开头的函数“认为”我们提供了和用户调用msyscall 时同样的参数的？**

- **内核处理系统调用的过程对Trapframe 做了哪些更改？这种修改对应的用户态的变化是？**

  

**Thinking 4.2 思考下面的问题，并对这两个问题谈谈你的理解：**

- **子进程完全按照fork() 之后父进程的代码执行，说明了什么？**
- **但是子进程却没有执行fork() 之前父进程的代码，又说明了什么？**

> 子进程完全按照父进程fork之后的代码执行，说明子进程的代码段和父进程的代码段是一致的。他们是同一个程序，只不过是两个不同的进程。然而子进程是从一半开始执行，虽然和父进程代码一样，可是开始的位置却不同。具体一点，子进程执行的代码的起始位置应该是父进程的epc。这一点在我们的代码中也有体现：
>
> `child->env_tf.pc = child->env_tf.cp0_epc;`



**Thinking 4.3 关于fork 函数的两个返回值，下面说法正确的是：**

**A. fork 在父进程中被调用两次，产生两个返回值**

**B. fork 在两个进程中分别被调用一次，产生两个不同的返回值**

**C. fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值**

**D. fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值**

> C



**Thinking 4.4 如果仔细阅读上述这一段话, 你应该可以发现, 我们并不是对所有的用户空间页都使用duppage 进行了保护。那么究竟哪些用户空间页可以保护，哪些不可以呢，请结合include/mmu.h 里的内存布局图谈谈你的看法。**

> 根据mmu.h中的内存布局，UTOP是用户空间的极限，duppage肯定为比UTOP小的地址空间服务。
>
> 其次，我们还注意到，UTOP也叫UXSTACKTOP （`#define UXSTACKTOP (UTOP)`）它的下面一页是 exception stack，每个进程的异常栈都是我们单独处理的，因这一页也不需要duppage。
>
> 综上，duppage保护的页应该是截至到(UTOP/BY2PG-1)这一页。



**Thinking 4.5 在遍历地址空间存取页表项时你需要使用到vpd 和vpt 这两个“指针的指针”，请思考并回答这几个问题：**

- **vpt 和vpd 的作用是什么？怎样使用它们？**
- **从实现的角度谈一下为什么能够通过这种方式来存取进程自身页表？**
- **它们是如何体现自映射设计的？**
- **进程能够通过这种存取的方式来修改自己的页表项吗？**

> vpd就也是页目录的位置，遍历页目录也就是遍历vpd。遍历vpd时，我们将所有分配给内存的物理页映射给子进程。遍历时还需要判断二级页表是否存在，存在则映射。在映射二级页表的同时，二级页表中分配的物理页也需要映射。 二级页表则通过vpt来访问。

**Thinking 4.6 page_fault_handler 函数中，你可能注意到了一个向异常处理栈复制Trapframe 运行现场的过程，请思考并回答这几个问题：**

- **这里实现了一个支持类似于“中断重入”的机制，而在什么时候会出现这种“中断重入”？**
- **内核为什么需要将异常的现场 Trapframe 复制到用户空间？**



**Thinking 4.7 到这里我们大概知道了这是一个由用户程序处理并由用户程序自身来恢复运行现场的过程，请思考并回答以下几个问题：**

- **用户处理相比于在内核处理写时复制的缺页中断有什么优势？**
- **从通用寄存器的用途角度讨论用户空间下进行现场的恢复是如何做到不破坏通用寄存器的？**



**Thinking 4.8 请思考并回答以下几个问题：**

- **为什么需要将set_pgfault_handler 的调用放置在syscall_env_alloc 之前？**
- **如果放置在写时复制保护机制完成之后会有怎样的效果？**
- **子进程需不需要对在entry.S 定义的字__pgfault_handler 赋值？**



